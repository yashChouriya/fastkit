# alembic/env.py
from __future__ import annotations

import os
from logging.config import fileConfig

import sqlalchemy as sa
from alembic import context
from alembic.autogenerate import renderers
from alembic.operations.ops import (
    DropTableOp,
    DropColumnOp,
    DropConstraintOp,
    DropIndexOp,
    CreateTableOp,
    AddColumnOp,
)
from sqlmodel import SQLModel
from sqlmodel.sql.sqltypes import AutoString

# --- Your app engine ---
from app.core.db import engine  # create_engine(...) defined here

# --- IMPORTANT: import ALL models so they register in SQLModel.metadata ---
# Do one of the following:
# from app.models import *  # if app/models/__init__.py imports all model modules
from app import models  # noqa: F401  <-- importing for side effects (registers models)

target_metadata = SQLModel.metadata

print("target_metadata: ", target_metadata)


# --- Make Alembic render SQLModel's AutoString as SA String for cleaner diffs ---
@renderers.dispatch_for(AutoString)
def _render_sqlmodel_autostring(type_, autogen_context):
    length = getattr(type_, "length", None)
    return f"sa.String(length={length})" if length else "sa.String()"


# Alembic Config
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


# ---------------- Safety rails ----------------
def _ensure_metadata_not_empty():
    """Fail fast if models weren't imported and metadata is empty."""
    if not target_metadata.tables:
        raise RuntimeError(
            "SQLModel.metadata is empty. Did you import all model modules in env.py?"
        )


def _include_object(obj, name, type_, reflected, compare_to):
    """
    Prevent autogenerate from proposing drops for tables that exist in the DB
    but aren't in metadata (often caused by missing imports).
    If you intentionally want to drop a table, write an explicit migration.
    """
    if type_ == "table" and reflected and compare_to is None:
        return False
    return True


def _process_revision_directives(context_, revision, directives):
    """
    Block 'drop-only' autogenerated revisions (common symptom when metadata is empty).
    Set ALLOW_DROPS=1 to bypass intentionally.
    """
    _ensure_metadata_not_empty()

    if not directives:
        return

    script = directives[0]
    ops = list(getattr(script.upgrade_ops, "ops", []))

    has_drop = any(
        isinstance(op, (DropTableOp, DropColumnOp, DropConstraintOp, DropIndexOp))
        for op in ops
    )
    has_create_or_add = any(isinstance(op, (CreateTableOp, AddColumnOp)) for op in ops)

    if has_drop and not has_create_or_add and os.environ.get("ALLOW_DROPS") != "1":
        raise RuntimeError(
            "Autogenerate produced a drop-only migration. "
            "This is usually a sign metadata wasn't loaded. "
            "Import your models or set ALLOW_DROPS=1 if you really mean it."
        )


# ------------------------------------------------


def run_migrations_offline():
    """Run migrations in 'offline' mode (no DB connection; emits SQL)."""
    _ensure_metadata_not_empty()

    context.configure(
        url=str(engine.url),
        target_metadata=target_metadata,
        compare_type=True,
        compare_server_default=True,
        include_object=_include_object,
        process_revision_directives=_process_revision_directives,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode (with a live DB connection)."""
    _ensure_metadata_not_empty()

    with engine.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True,
            compare_server_default=True,
            include_object=_include_object,
            process_revision_directives=_process_revision_directives,
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
