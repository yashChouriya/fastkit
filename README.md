# fastkit

A modular FastAPI starter kit with PostgreSQL, SQLAlchemy, JWT auth, and WebSocket support.

---

## 1. High-level project layout

```
project-root/
├── .env.example                  # Template env vars (DB URL, secrets, expirations)
├── .env                          # Local environment overrides (ignored in VCS)
├── README.md
├── pyproject.toml / requirements.txt
├── .gitignore
├── docker-compose.yml           # Postgres service (and optional redis, etc.)
├── Dockerfile                   # If containerizing the app
├── app/
│   ├── main.py                  # starting point of the app includes fast api app initialization
│   ├── core/                    # Configuration, secrets, security utilities
│   │   ├── config.py
│   │   ├── security.py          # Password hashing, token helpers
│   │   └── jwt_utils.py         # JWT creation/validation logic
│   ├── db/                      # DB setup & models
│   │   ├── base.py              # Declarative base import
│   │   ├── session.py           # Engine / session factory
│   │   ├── models/
│   │   │   ├── user.py
│   │   │   └── token.py         # Refresh (and optionally blacklisted access) tokens
│   │   └── migrations/          # Alembic configs and autogenerated migrations
│   ├── schemas/                 # Pydantic request/response models
│   │   ├── user.py
│   │   └── token.py
│   ├── repositories/            # DB access abstractions
│   │   ├── user_repo.py
│   │   └── token_repo.py
│   ├── services/                # Business logic
│   │   ├── user_service.py
│   │   └── auth_service.py
│   ├── api/
│   │   └── v1/
│   │       ├── dependencies/     # Auth/permission dependencies
│   │       └── routers/
│   │           ├── auth.py       # Login, refresh, logout, registration
│   │           ├── users.py      # User CRUD / profile endpoints
│   │           └── ws.py         # WebSocket endpoint(s)
│   ├── utils/                   # Misc helpers (e.g., time, validators)
│   ├── logging/                # Logging setup if customized
│   └── tests/
│       ├── unit/
│       └── integration/         # Fixtures with test DB
└── scripts/                    # e.g., run migrations, bootstrap, etc.
```

---

## 2. Step-by-step implementation flow (milestones)

### **Milestone 1: Environment & scaffolding**

1. Initialize repo, add `.gitignore`, README template.
2. Choose Python version (3.11+ recommended). Set up virtual environment.
3. Create `pyproject.toml` or `requirements.txt` with core dependencies:

   - `fastapi`, `uvicorn`
   - `SQLAlchemy` (async if using async style), `asyncpg`
   - `alembic`
   - `pydantic`
   - `python-jose` or similar for JWT
   - `passlib[bcrypt]` for password hashing
   - Optional: `python-dotenv` for `.env` loading, `httpx` for tests, `pytest`, `pytest-asyncio`

4. Create `.env.example` with placeholders: database URL, JWT secret(s), token expiry settings.
5. Set up `docker-compose.yml` with PostgreSQL service for local development (with volume, user/pass, database).
6. Implement config loader in `app/core/config.py` to read env vars (DB URL, secrets, expirations).

### **Milestone 2: Database connection and migrations**

1. In `app/db/session.py`, configure SQLAlchemy engine and session maker (async or sync as per choice). Provide dependency to yield a session.
2. Set up base declarative in `app/db/base.py` and import model modules there.
3. Initialize Alembic:

   - Configure `alembic.ini` and env.py to use the same connection and metadata from your `Base`.
   - Create initial migration scaffold.

4. Prepare test database configuration (separate URL, ephemeral or in-memory if possible).

### **Milestone 3: Define core models**

1. **User model** (`app/db/models/user.py`):

   - Fields: id (UUID or integer), email (unique), hashed_password, is_active, is_superuser/roles, created_at, updated_at.

2. **Token model** (`app/db/models/token.py`):

   - Store refresh tokens (never store raw access tokens unless implementing blacklist—better to store token identifiers like `jti` if you need revocation).
   - Fields: id, user_id (FK), token_type (e.g., "refresh"), jti or token identifier (hashed), created_at, expires_at, revoked (bool), optionally device info / fingerprint, replaced_by (for rotation).

3. Generate and apply migration to create these tables.

### **Milestone 4: Authentication primitives**

1. Password handling:

   - Define hash and verify functions (e.g., bcrypt) in `core/security.py`.

2. JWT handling:

   - Define creation of access and refresh tokens with claims (user_id, exp, jti, type).
   - Choose signing method (HMAC with strong secret or asymmetric if desired).
   - Decide expiration policy: short-lived access (e.g., 15 minutes), longer refresh (e.g., 7 days).

3. Token storage strategy:

   - On login, create refresh token, persist its identifier (jti) hashed in DB with expiration.
   - Access tokens by default not persisted unless you implement revocation (optional).

### **Milestone 5: User registration and login flow**

1. **Registration endpoint**:

   - Accept email + password; validate uniqueness.
   - Hash password; create user record.

2. **Login endpoint**:

   - Validate credentials (verify password).
   - Issue access and refresh tokens.
   - Persist refresh token record in DB.
   - Return tokens to client (e.g., JSON body).

3. Implement appropriate response schemas for login/registration.

### **Milestone 6: Token usage & protection**

1. **Access token verification dependency**:

   - Middleware or dependency that:

     - Extracts Bearer token from Authorization header.
     - Decodes and validates JWT (signature, expiry, expected type).
     - Fetches user and ensures active.
     - Optionally checks token isn’t revoked (if you store access token jti blacklist).
     - Injects user into route context.

2. **Protected routes**:

   - Apply dependency to sample HTTP route (e.g., “get current user”, or a protected resource).

3. **Refresh endpoint**:

   - Accept refresh token.
   - Decode and validate.
   - Look up stored refresh token record; ensure not revoked/expired.
   - (Optional) Rotate refresh token: issue new refresh token, mark old as revoked/replaced.
   - Issue new access token (and possibly new refresh token).

4. **Logout endpoint**:

   - Revoke the provided refresh token (and optionally access token via blacklist).

### **Milestone 7: Authorization**

1. Define roles/permissions on user (e.g., `is_superuser`, role field, or a separate permission table).
2. Create dependency for role-based access:

   - E.g., `require_admin`, `require_owner_or_admin` etc.

3. Apply to specific routes.

### **Milestone 8: WebSocket integration**

1. Create WebSocket router (`app/api/v1/routers/ws.py`).
2. Authentication over WS:

   - On connection handshake, accept token (e.g., query param, initial message, or header if proxy allows).
   - Validate access token similarly to HTTP.
   - Reject connection if invalid/expired.
   - Attach user context to WS session.

3. Structure message handling logic; ensure authorization if certain actions are privileged.

### **Milestone 9: Organize services/repositories**

1. Move raw DB logic into repository layer (`user_repo`, `token_repo`).
2. Centralize business logic in services (`user_service`, `auth_service`) so routers stay thin.
3. Keep schema conversions (Pydantic) in appropriate layer (e.g., return DTOs).

### **Milestone 10: Testing**

1. Write unit tests for:

   - Password hashing and verification.
   - JWT creation and validation.
   - User creation/login flows.

2. Integration tests:

   - End-to-end registration → login → access protected route.
   - Refresh token flow, including rotation and revocation.
   - WebSocket authentication.

3. Use test fixtures to spin up a temporary test database and isolate transactions.

### **Milestone 11: Operational concerns & hardening**

1. Centralized error handling and standardized API error responses.
2. Logging setup (structured logs, avoid leaking secrets).
3. Rate limiting (optional—for login endpoints).
4. Security:

   - Enforce HTTPS in deployment.
   - Use strong secrets and rotate them.
   - Limit login attempts / consider captchas for brute force.
   - Secure storage of refresh tokens (hashed in DB).
   - Set appropriate CORS policies.

5. Token invalidation strategy (e.g., on password change, revoke all existing refresh tokens).

### **Milestone 12: Deployment automation**

1. Containerization (if desired) with environment variable injection.
2. Migration application on startup.
3. Health checks and readiness probes.
4. Secrets management for production (vault, environment secrets, etc.)

---

## 3. First concrete task breakdown (user + auth token model + flow)

**Phase A: Foundation**

1. Define environment variables: DB connection string, JWT secret, access/refresh expirations.
2. Set up DB connection and Alembic.
3. Create `User` and `Token` models and apply migration.

**Phase B: Authentication primitives**
4\. Implement password hashing/verification.
5\. Implement JWT creation/validation with `jti`, expiration, and token type claim.

**Phase C: Core endpoints**
6\. Registration endpoint:

- Validate input, hash password, create user.

7. Login endpoint:

   - Verify credentials.
   - Create access token (short-lived) and refresh token (longer).
   - Persist refresh token record with its `jti`, expiry, and link to user.
   - Return tokens.

**Phase D: Protection & refresh**
8\. Access token validator dependency.
9\. Protected sample endpoint using that dependency.
10\. Refresh endpoint:
\- Validate provided refresh token against stored record.
\- Rotate if applicable: revoke old, persist new.
\- Return new access (and refresh) tokens.
11\. Logout:
\- Revoke the refresh token so it cannot be reused.

**Phase E: Authorization**
12\. Add role/permission mechanism.
13\. Protect endpoints beyond authentication.

---

## 4. Auxiliary recommendations

- **Token storage detail:** Store only refresh token identifiers (e.g., a hashed `jti`) so if DB leaks, raw tokens aren’t exposed. Access tokens can remain stateless unless you need forced invalidation.
- **Token rotation:** On every refresh, issue a new refresh token and revoke the previous one to mitigate replay.
- **Replay protection:** Track last-used `jti` for refresh tokens and detect reuse of revoked tokens (possible compromise).
- **Session invalidation:** If password changes, revoke all refresh tokens for that user.

---

## 5. Suggested incremental milestones to follow as you build

1. Scaffold + config + DB connection.
2. Models + migrations.
3. Registration + login + token issuance.
4. Protect a route with access token.
5. Refresh flow + token rotation.
6. Logout + revocation.
7. Role-based authorization.
8. WebSocket auth.
9. Comprehensive tests.
10. Deployment readiness.
